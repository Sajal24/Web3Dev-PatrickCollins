leIt's going to be fun!

DEBUGGING
This is going to be the piece that is going to give you the superpower to unblock yourself from any coding issue I run into!

Tinker and figure out yourself - keep hitting and trying
Limit tinkering to 20 minutes -> take at least 15 min yourself -> exhaust yourself completely trying all the options

1. Tinker and try to pinpoint exactly what's going on
2. Google the exact error - be patient, explore all answers patiently
3. Ask a question on a forum like Stack Exchange ETH and Stack Overflow

Five steps from the original yt video of Patrick about Debugging:

1. Tinker and Experiment - Pinpoint exactly what's going wrong here
2. Check the docs
3. Google!
4. Ask questions on Forums
5. Join & Strengthen the community and tool



INSTALLATION & SETUP
Hardhat - a smart contract developer framework similar to brownie or foundry.
then why Hardhat? - coz it's JS based development environment

first we will learn Ethers.js - a js based library for working with smart contracts

gitpod - a cloud development environment - run your code on a remote server, similar to remix IDE but allows you to run VS Code in the browser or connected to another server.



COMPILING OUR SOLIDITY CODE
we need to install a solidity compiles - npm install solc
or yarn add solc

then add a script: {
    "compile": "yarn solcjs --bin --abi --include-path node_modules/ --base-path . -o . SimpleStorage.sol"
}

used to compile your code/



GANACHE & NETWORKS
Similar to a virtual machine in remix - ganache is one of that application.

Ganache - Quickly fire up a personal Ethereum blockchain which you can use to run tests, execute commands, and inspect state while controlling how the chain operates.

RPC - remote procedure call is the imp thing here - stands for a connection to a blockchain node that somebody is running - this rpc url helps us make API calls to and interact with a blockchain node



INTRO TO ETHERS.JS
same as web3js but we be using ethers is coz it powers the Hardhat environment, which we'll be using

1. install ethers - yarn add ethers

2. import ethers to your file -> const ethers = require("ethers")
now ethers gives us many features and functions - out of which wrappers are used to make those api calls - create our provider object in our main function - instead of us dealing with all those fetch and axios requests

NOW WE need a provider, a signer and the contract:

3. Now make a provider function and use the RPC of ganache
  -> this is the way our script is going to connect to our blockchain, provides a read-only access to the blockchain and its status.

4. now we need a signer - our wallet's private key - to sign deploying this contract

5. now in order to deploy our contract to the blockchain, we need ABI and the binary compiled code of the contract
 -> we'll be using 'fs' and locate those two files

6. now we need to create a contract factory - just a ethers object you can use to deploy contracts - 
    const contractFactory = new ethers.ContractFactory(abi, binary, wallet);

7. done, now deploy!
    const contract = await contractFactory.deploy();

DONE - you just deployed your smart contract to your local blockchain using ethersjs

* TOH BASICALLY - to deploy a contract:
 1. we need the blockchain's RPC url and our wallet's private key
 2. we need the ABI and binary code of our contract to be deployed



ADDING TRANSACTION OVERRIDES
Basically all the extra things like choosing how much ether to send, setting the gas priority fee, etc, eg-
    const contract = await contractFactory.deploy({gasPrice: 100000});



TRANSACTION RECEIPTS
Transaction receipt is different from Transaction Response (deployment Transaction) as deployment Transaction is simply a response that the transaction is deployed while transaction receipt is when you wait for block confirmation and then get the receipt
 eg - const transactionReceipt = await contract.deployTransaction.wait(1);
 means wait for 1 block confirmation - give us the transaction receipt when 1 block is confirmed to the blockchain - can change the wait parameter.



SENDING A 'RAW' TRANSACTION IN ETHERSJS
Deploying a contract is essentally sending a transaction 
here in this transaction, we are defining a transaction by ourselves, and then using our wallet (our private key) to sign the transaction and send it to the blockchain

if you are sending a transaction - that automatically signs the transaction first (its written in its function already to sign first and then send the transaction to the block), eg - 
    console.log("Let's deploy this with transaction data only");

  //   const nonce = await wallet.getTransactionCount();

  //   const tx = {
  //     nonce: nonce,
  //     gasPrice: 20000000000,
  //     gasLimit: 1000000,
  //     to: null,
  //     value: 0,
  //     data: "put the .bin data here"
  //     chainId: 1337,
  //   };

  //   const sentTxResponse = await wallet.sendTransaction(tx);
  //   await sentTxResponse.wait(1);
  //   console.log(sentTxResponse);



INTERACTING WITH CONTRACTS IN ETHERSJS
its best to get and pass parameter/values in string format (or Big Number format) as JS ki phatt jaati hi when dealing with big numbers (acc to IEEE 754), so when receiving a number, stringify it (.toString()) and when passing an arguement - ("7").